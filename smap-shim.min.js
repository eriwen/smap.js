//! Copyright 2012 Eric Wendelin - MIT License
(function(a){function b(a){var b=[],c=[],f=[],j=Object.is||function(d,a){return d===a?0!==d||1/d==1/a:d!=d&&a!=a},g=function(d){if(d!=d||0===d)for(var a=this.length;a--&&!j(this[a],d););else a=[].indexOf.call(this,d);return a},k=function(d,a){var b=0;return Object.create({},{next:{value:function(){if(b<d.items().length)switch(a){case "keys":return d.keys()[b++];case "values":return d.values()[b++];case "keys+values":return[].slice.call(d.items()[b++]);default:throw new TypeError("Invalid iterator type");
}throw Error("Stop Iteration");}},iterator:{value:function(){return this}},toString:{value:function(){return"[object Map Iterator]"}}})},h=function(d,a){var e=g.call(c,d);-1<e?(b[e]=a,f[e]=a):(b.push([d,a]),c.push(d),f.push(a))},l=function(a){if(2!==a.length)throw new TypeError("Invalid iterable passed to Map constructor");h(a[0],a[1])};if(Array.isArray(a))a.forEach(l);else if(void 0!==a)throw new TypeError("Invalid Map");return Object.create(e,{items:{value:function(){return[].slice.call(b)}},keys:{value:function(){return[].slice.call(c)}},
    values:{value:function(){return[].slice.call(f)}},has:{value:function(a){return-1<g.call(c,a)}},get:{value:function(a){a=g.call(c,a);return-1<a?f[a]:void 0}},set:{value:h},size:{get:function(){return b.length}},clear:{value:function(){c.length=f.length=b.length=0}},"delete":{value:function(a){a=g.call(c,a);return-1<a?(c.splice(a,1),f.splice(a,1),b.splice(a,1),!0):!1}},forEach:{value:function(a,b){function c(){try{return e.next()}catch(a){}}if("function"!=typeof a)throw new TypeError("Invalid callback function given to forEach");
        for(var e=this.iterator(),f=c(),g=c();void 0!==f;)a.apply(b,[f[1],f[0],this]),f=g,g=c()}},iterator:{value:function(){return new k(this,"keys+values")}},toString:{value:function(){return"[Object Map]"}}})}var c=(a="undefined"==a)?this:global,a=a?{}:exports,e=b.prototype;b.prototype=e=b();c.Map=a.Map=c.Map||b}).call(this,typeof exports);
(function(){Map.prototype.filter=function(a){if("function"!=typeof a)throw new TypeError("Expected a function argument");var b=new Map;this.forEach(function(c,e,i){a(e,c,i)&&b.set(e,c)});return b};Map.prototype.merge=function(a){function b(a,b){c.set(b,a)}if(!(a instanceof Map))throw new TypeError("Cannot merge with objects that are not Maps");var c=new Map;this.forEach(b);a.forEach(b);return c};Map.prototype.fetch=function(a,b){return this.has(a)?this.get(a):b};Map.prototype.invert=function(){var a=
    new Map;this.forEach(a.set);return a};Map.prototype.reject=function(a){if("function"!=typeof a)throw new TypeError("Expected a function argument");this.forEach(function(b,c,e){if(a(c,b,e))e["delete"](c)}.bind(this))};Map.prototype.isEmpty=function(){return 0===this.keys().length}})();